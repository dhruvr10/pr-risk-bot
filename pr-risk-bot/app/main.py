from __future__ import annotations

import hmac
import hashlib
import json
from typing import Any, Dict, Optional, List

from fastapi import FastAPI, Header, HTTPException, Request
from fastapi.responses import JSONResponse

from .config import load_settings
from .github import GitHubClient
from .risk import compute_risk

app = FastAPI(title="PR Risk Bot", version="1.0.0")

settings = load_settings()
gh = GitHubClient(token=settings.github_token, base_url=settings.base_url)

def verify_signature(body: bytes, signature_header: Optional[str], secret: str) -> None:
    if not signature_header or not signature_header.startswith("sha256="):
        raise HTTPException(status_code=401, detail="Missing/invalid signature header")
    their_sig = signature_header.split("=", 1)[1].strip()

    mac = hmac.new(secret.encode("utf-8"), msg=body, digestmod=hashlib.sha256)
    our_sig = mac.hexdigest()

    if not hmac.compare_digest(our_sig, their_sig):
        raise HTTPException(status_code=401, detail="Signature mismatch")

def make_comment(pr: Dict[str, Any], result) -> str:
    url = pr.get("html_url", "")
    title = pr.get("title", "")
    number = pr.get("number", "")
    user = (pr.get("user") or {}).get("login", "unknown")

    lines: List[str] = []

    lines.append("## PR Triage Summary")
    lines.append(f"- PR: [{title} #{number}]({url})")
    lines.append(f"- Author: `{user}`")
    lines.append(f"- Risk: **{result.score_10}/10 ({result.level})** â€” confidence: **{result.confidence}**")
    lines.append(f"- Summary: {result.changed_files} files, {result.additions}+/{result.deletions}-")
    lines.append("")

    lines.append("### What changed (impact map)")
    if result.impact_map:
        for item in result.impact_map[:8]:
            lines.append(f"- {item}")
    else:
        lines.append("- (Could not infer impact map)")
    lines.append("")

    lines.append("### Risk drivers")
    if result.risk_drivers:
        for i, d in enumerate(result.risk_drivers[:6], start=1):
            lines.append(f"{i}. {d}")
    else:
        lines.append("1. (No strong drivers detected)")
    lines.append("")

    lines.append("### Suggested review focus")
    if result.review_focus:
        for item in result.review_focus[:5]:
            lines.append(f"- {item}")
    else:
        lines.append("- (No specific review focus detected)")
    lines.append("")

    lines.append("### Operational notes (if applicable)")
    if result.operational_notes:
        for n in result.operational_notes[:5]:
            lines.append(f"- {n}")
    else:
        lines.append("- None")
    lines.append("")

    lines.append("> Generated by pr-risk-bot (heuristics-first).")

    return "\n".join(lines)


@app.post("/webhook/github")
async def github_webhook(
    request: Request,
    x_hub_signature_256: Optional[str] = Header(default=None),
    x_github_event: Optional[str] = Header(default=None),
) -> JSONResponse:
    body = await request.body()
    verify_signature(body, x_hub_signature_256, settings.webhook_secret)

    try:
        payload = json.loads(body.decode("utf-8"))
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON")

    if x_github_event != "pull_request":
        return JSONResponse({"ok": True, "ignored": True, "reason": "not pull_request"})

    action = payload.get("action")
    if action not in {"opened", "reopened", "synchronize"}:
        return JSONResponse({"ok": True, "ignored": True, "reason": f"action={action}"})

    pr = payload.get("pull_request") or {}
    pr_number = pr.get("number")
    repo = payload.get("repository") or {}
    owner = (repo.get("owner") or {}).get("login")
    repo_name = repo.get("name")

    if not (owner and repo_name and pr_number):
        raise HTTPException(status_code=400, detail="Missing repo/pr info")

    pr_full = gh.get_pr(owner, repo_name, int(pr_number))
    files = gh.list_pr_files(owner, repo_name, int(pr_number))

    result = compute_risk(files, pr_full)
    comment = make_comment(pr_full, result)

    gh.create_issue_comment(owner, repo_name, int(pr_number), comment)

    return JSONResponse({"ok": True, "posted": True, "risk": result.level, "score": result.score})

@app.get("/health")
async def health() -> Dict[str, Any]:
    return {"ok": True}
